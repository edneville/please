.\" Automatically generated by Pandoc 2.2.1
.\"
.TH "please.ini" "5" "27 January 2021" "please 0.3.21" "User Manual"
.hy
.SH NAME
.PP
please.ini \- configuration file for access
.SH DESCRIPTION
.PP
The \f[B]please.ini\f[] file contains one or more \f[B][sections]\f[]
that hold ACL for users of the \f[B]please\f[] and \f[B]pleaseedit\f[]
programs.
.PP
All rules in \f[C]please.ini\f[] will permit or deny based on command
regex matches.
.PP
\f[C]please.ini\f[] is an ini file, and as such it makes sense to label
the sections with a good short description of what the section provides.
You may then find this helpful when listing rights with \f[B]please
\-l\f[].
.PP
Rules are read and applied in the order they are presented in the
configuration file.
If the user matches a permit rule to run a command in an early section,
but in a later section matches a deny regex for \f[C]\&.*\f[], then the
user will not be permitted to run any command.
The last match wins.
.PP
The properties in ini permitted are described below and should appear at
most once per section.
If a property is used more than once in a section, the last one will be
used.
.SH SECTION OPTIONS
.TP
.B \f[B][section\-name]\f[]
section name, shown in list mode
.RS
.RE
.TP
.B \f[B]include=[file]\f[]
read ini file, and continue to next section
.RS
.RE
.TP
.B \f[B]includedir=[directory]\f[]
read .ini files in directory, and continue to next section
.RS
.RE
.SH MATCHES
.TP
.B \f[B]name=[regex]\f[]
mandatory, the user or \f[B]group\f[] (see below) to match against.
.RS
.RE
.TP
.B \f[B]target=[regex]\f[]
user to execute or list as, defaults to root
.RS
.RE
.TP
.B \f[B]regex=[regex]\f[]
is the regular expression that the command matches against, defaults to
^$
.RS
.RE
.TP
.B \f[B]notbefore=[YYYYmmdd|YYYYmmddHHMMSS]\f[]
will add HHMMSS as 00:00:00 to the date if not given, defaults to never
.RS
.RE
.TP
.B \f[B]notafter=[YYYYmmdd|YYYYmmddHHMMSS]\f[]
will add 23:59:59 to the date if not given, defaults to never
.RS
.RE
.TP
.B \f[B]datematch=[Day dd Mon HH:MM:SS UTC YYYY]\f[]
regex to match against a date string
.RS
.RE
.TP
.B \f[B]type=[edit/run/list]\f[]
defaults to run, edit = pleaseedit entry, list = user access rights
listing
.RS
.RE
.TP
.B \f[B]group=[true|false]\f[]
defaults to false, when true name refers to a group rather than a user
.RS
.RE
.TP
.B \f[B]hostname=[regex]\f[]
permitted hostnames where this may apply, defaults to localhost
.RS
.RE
.TP
.B \f[B]dir=[regex]\f[]
permitted regex for switchable directories, defaults to any
.RS
.RE
.PP
\f[C]regex\f[] is a regular expression, \f[B]%{USER}\f[] will expand to
the user who is currently running \f[C]please\f[].
This enables a single rule for a group to modify/run something that
matches their name.
.SH ACTIONS
.TP
.B \f[B]exitcmd=[program]\f[]
run program after editor exits, if exit is zero, continue with file
replacement.
\f[B]%{NEW}\f[] and \f[B]%{OLD}\f[] placeholders expand to new and old
edit files
.RS
.RE
.TP
.B \f[B]permit=[true|false]\f[]
permit or disallow the entry, defaults to true
.RS
.RE
.TP
.B \f[B]require_pass=[true|false]\f[]
if entry matches, require a password, defaults to true
.RS
.RE
.TP
.B \f[B]editmode=[octal mode]\f[]
set the file mode bits on replacement file to octal mode
.RS
.RE
.TP
.B \f[B]reason=[true|false]\f[]
require a reason for execution/edit, defaults to false
.RS
.RE
.TP
.B \f[B]last=[true|false]\f[]
if true, stop processing when entry is matched, defaults to false
.RS
.RE
.TP
.B \f[B]syslog=[true|false]\f[]
log this activity to syslog, defaults to true
.RS
.RE
.SH EXAMPLES
.PP
To allow all commands, you can use a greedy match (\f[C]^.*$\f[]).
You should probably reduce this to the set of acceptable commands
though.
.IP
.nf
\f[C]
[user_ed_root]
name=ed
target=root
regex=^.*$
\f[]
.fi
.PP
If you wish to permit a user to view another's command set, then you may
do this using \f[C]type=list\f[] (\f[C]run\f[] by default).
To list another user, they must match the \f[C]target\f[] regex.
.IP
.nf
\f[C]
[user_ed_list_root]
name=ed
type=list
target=root
\f[]
.fi
.PP
\f[C]type\f[] may also be \f[C]edit\f[] if you wish to permit a file
edit with \f[C]pleaseedit\f[].
.IP
.nf
\f[C]
[user_ed_edit_hosts]
name=ed
type=edit
target=root
regex=^/etc/hosts$
\f[]
.fi
.PP
Naming sections should help later when listing permissions.
.PP
Below, user \f[B]mandy\f[] may run \f[B]du\f[] without needing a
password, but must enter a password for \f[B]bash\f[]:
.IP
.nf
\f[C]
[mandy_du]
name\ =\ mandy
regex\ =\ ^(/usr)?/bin/du\\s+.*$
require_pass\ =\ false

[mandy_some]
name\ =\ mandy
regex\ =\ ^(/usr)?/bin/bash$
require_pass\ =\ true
\f[]
.fi
.PP
\f[C]regex\f[] can include repetitions.
To permit running \f[C]wc\f[] to count the lines in the log files (we
don't know how many there are) in \f[C]/var/log\f[].
This sort of regex will allow multiple instances of a \f[C]()\f[] group
with \f[C]+\f[], which is used to define the character class
\f[C][a\-zA\-Z0\-9\-]+\f[], the numeric class \f[C]\\d+\f[] and the
group near the end of the line.
In other words, multiple instances of files in /var/log that may end in
common log rotate forms \f[C]\-YYYYMMDD\f[] or \f[C]\&.N\f[].
.PP
This will permit commands such as the following, note how for efficiency
find will combine arguments with \f[C]\\+\f[] into fewer invocations.
\f[C]xargs\f[] could have been used in place of \f[C]find\f[].
.IP
.nf
\f[C]
$\ find\ /var/log\ \-type\ f\ \-exec\ please\ /usr/bin/wc\ {}\ \\+
\f[]
.fi
.PP
Here is a sample for the above scenario:
.IP
.nf
\f[C]
[user_ed_root]
name=ed
target=root
permit=true
regex=^/usr/bin/wc\ (/var/log/[a\-zA\-Z0\-9\-]+(\\.\\d+)?(\\s)?)+$
\f[]
.fi
.PP
User \f[C]ed\f[] may only start or stop a docker container:
.IP
.nf
\f[C]
[user_ed_root]
name=ed
target=root
permit=true
regex=^/usr/bin/docker\ (start|stop)\ \\S+
\f[]
.fi
.PP
User \f[C]ben\f[] may only edit \f[C]/etc/fstab\f[]:
.IP
.nf
\f[C]
[ben_fstab]
name=ben
target=root
permit=true
type=edit
regex=^/etc/fstab$
\f[]
.fi
.PP
User \f[C]ben\f[] may list only users \f[C]eng\f[], \f[C]net\f[] and
\f[C]dba\f[] operators:
.IP
.nf
\f[C]
[ben_ops]
name=ben
permit=true
type=list
target=^(eng|net|dba)ops$
\f[]
.fi
.PP
All users may list their own permissions.
You may or may not wish to do this if you consider permitting a view of
the rules to be a security risk.
.IP
.nf
\f[C]
[list_own]
name=^%{USER}$
permit=true
type=list
target=^%{USER}$
\f[]
.fi
.SH EXITCMD
.PP
When the user completes their edit, and the editor exits cleanly, if
\f[C]exitcmd\f[] is included then the program will run.
If the program also exits cleanly then the temporary edit will be copied
to the destination.
.PP
\f[B]%{OLD}\f[] and \f[B]%{NEW}\f[] will expand to the old (existing
source) file and edit candidate, respectively.
To verify a file edit, \f[B]ben\f[]'s entry to check \f[C]/etc/hosts\f[]
after clean exit could look like this:
.IP
.nf
\f[C]
[ben_ops]
name=ben
permit=true
type=edit
regex=^/etc/hosts$
exitcmd=/usr/local/bin/check_hosts\ %{OLD}\ %{NEW}
\f[]
.fi
.PP
\f[C]/usr/local/bin/check_hosts\f[] would take two arguments, the
original file as the first argument and the modify candidate as the
second argument.
If \f[C]check_hosts\f[] terminates zero, then the edit is considered
clean and the original file is replaced with the candidate.
Otherwise the edit file is not copied and is left, \f[C]pleaseedit\f[]
will exit with the return value from \f[C]check_hosts\f[].
.PP
A common \f[C]exitcmd\f[] is to check the validity of
\f[C]please.ini\f[], shown below.
This permits members of the \f[C]admin\f[] group to edit
\f[C]/etc/please.ini\f[] if they provide a reason (\f[B]\-r\f[]).
Upon clean exit from the editor the tmp file will be syntax checked.
.IP
.nf
\f[C]
[please_ini]
name\ =\ admins
group\ =\ true
reason\ =\ true
regex\ =\ /etc/please.ini
type\ =\ edit
editmode\ =\ 600
exitcmd\ =\ /usr/bin/please\ \-c\ %{NEW}
\f[]
.fi
.SH DATED RANGES
.PP
For large environments it is not unusual for a third party to require
access during a short time frame for debugging.
To accommodate this there are the \f[C]notbefore\f[] and
\f[C]notafter\f[] time brackets.
These can be either \f[C]YYYYmmdd\f[] or \f[C]YYYYMMDDHHMMSS\f[].
.PP
The whole day is considered when using the shorter date form of
\f[C]YYYYMMDD\f[].
.PP
Many enterprises may wish to permit access to a user for a limited time
only, even if that individual is in the role permanently.
.PP
User joker can do what they want as root on \f[C]1st\ April\ 2021\f[]:
.IP
.nf
\f[C]
[joker_april_first]
name=joker
target=root
permit=true
notbefore=20210401
notafter=20210401
regex=^/bin/bash
\f[]
.fi
.SH DATEMATCHES
.PP
Another date type is the \f[C]datematch\f[] item, this constrains
sections to a regex match against the date string
\f[C]Day\ dd\ mon\ HH:MM:SS\ UTC\ Year\f[].
.PP
You can permit some a group of users to perform some house keeping on a
Monday:
.IP
.nf
\f[C]
[l2_housekeeping]
name=l2users
group=true
target=root
permit=true
regex\ =\ /usr/local/housekeeping/.*
datematch\ =\ ^Thu\\s+1\\s+Oct\\s+22:00:00\\s+UTC\\s+2020
\f[]
.fi
.SH REASONS
.PP
When \f[C]true\f[], require a reason before permitting edits or
execution with the \f[B]\-r\f[] option.
Some organisations may prefer a reason to be logged when a command is
executed.
This can be helpful for some situations where something such as
\f[C]mkfs\f[] or \f[C]useradd\f[] might be preferable to be logged
against a ticket.
.IP
.nf
\f[C]
[l2_user_admin]
name=l2users
group=true
target=root
permit=true
reason=true
regex\ =\ ^/usr/sbin/useradd\\s+\-m\\s+\\w+$
\f[]
.fi
.SH LAST
.PP
To stop processing at a match, \f[B]last=true\f[] can be applied:
.IP
.nf
\f[C]
[mkfs]
name=l2users
group=true
target=root
permit=true
reason=true
regex\ =\ ^/sbin/mkfs.(ext[234]|xfs)\ /dev/sd[bcdefg]\\d?$
last=true
\f[]
.fi
.PP
For simplicity, there is no need to process other configured rules if
certain that the \f[C]l2users\f[] group are safe to execute this.
\f[C]last\f[] should only be used in situations where there will never
be something that could contradict the match later.
.SH FILES
.PP
/etc/please.ini
.SH CONTRIBUTIONS
.PP
I welcome pull requests with open arms.
New features always considered.
.SH BUGS
.PP
Found a bug?
Please either open a ticket or send a pull request/patch.
.SH SEE ALSO
.PP
please
.SH AUTHORS
Ed Neville (ed\-please\@s5h.net).
