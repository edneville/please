.\" Automatically generated by Pandoc 2.2.1
.\"
.TH "please.ini" "5" "25 June 2021" "please 0.4.1" "User Manual"
.hy
.SH NAME
.PP
please.ini \- configuration file for access
.SH DESCRIPTION
.PP
The \f[B]please.ini\f[] file contains one or more \f[B][sections]\f[]
that hold ACL for users of the \f[B]please\f[] and \f[B]pleaseedit\f[]
programs.
.PP
\f[C]please.ini\f[] is an ini file, sections can be named with a short
description of what the section provides.
You may then find this helpful when listing rights with \f[B]please
\-l\f[].
.PP
Rules are read and applied in the order they are presented in the
configuration file.
For example, if the user matches a permit rule to run a command in an
early section, but in a later section matches criteria for a deny and no
further matches, then the user will not be permitted to run that
command.
The last match wins.
.PP
The properties permitted are described below and should appear at most
once per section.
If a property is used more than once in a section, the last one will be
used.
.SH SECTION OPTIONS
.TP
.B \f[B][section\-name]\f[]
section name, shown in list mode
.RS
.RE
.TP
.B \f[B]include=[file]\f[]
read ini file, and continue to next section
.RS
.RE
.TP
.B \f[B]includedir=[directory]\f[]
read .ini files in directory, and continue to next section
.RS
.RE
.SH MATCHES
.TP
.B \f[B]name=[regex]\f[]
mandatory, the user or \f[B]group\f[] (see below) to match against
.RS
.RE
.TP
.B \f[B]target=[regex]\f[]
user to execute or list as, defaults to \f[B]root\f[]
.RS
.RE
.TP
.B \f[B]regex=[regex]\f[]
the regular expression that the command or edit path matches against,
defaults to ^$
.RS
.RE
.TP
.B \f[B]notbefore=[YYYYmmdd|YYYYmmddHHMMSS]\f[]
will add HHMMSS as 00:00:00 to the date if not given, defaults to never
.RS
.RE
.TP
.B \f[B]notafter=[YYYYmmdd|YYYYmmddHHMMSS]\f[]
will add 23:59:59 to the date if not given, defaults to never
.RS
.RE
.TP
.B \f[B]datematch=[Day dd Mon HH:MM:SS UTC YYYY]\f[]
regex to match a date string with
.RS
.RE
.TP
.B \f[B]type=[edit/run/list]\f[]
this section's mode behaviour, defaults to \f[B]run\f[], edit =
\f[B]pleaseedit\f[] entry, list = user access rights listing
.RS
.RE
.TP
.B \f[B]group=[true|false]\f[]
defaults to false, when true, the \f[B]name\f[] (above) refers to a
group rather than a user
.RS
.RE
.TP
.B \f[B]hostname=[regex]\f[]
permitted hostnames where this may apply, defaults to localhost
.RS
.RE
.TP
.B \f[B]dir=[regex]\f[]
permitted directories to run within
.RS
.RE
.TP
.B \f[B]permit_env=[regex]\f[]
allow environments that match \f[B]regex\f[] to be passed through
.RS
.RE
.PP
\f[B]regex\f[] is a regular expression, \f[B]%{USER}\f[] will expand to
the user who is currently running \f[C]please\f[].
This enables a single rule for a group to modify/run something that
matches their name.
.PP
Spaces within arguments will be substituted as \f[B]`\\\ '\f[]
(backslash space).
Use \f[B]^/bin/echo hello\\\\ world$\f[] to match \f[B]/bin/echo
\[lq]hello world\[rq]\f[], note that \f[B]\\\f[] is a regex escape
character so it must be escaped, therefore matching a space becomes
\f[B]`\\\\\ '\f[] (backslash backslash space).
.SH ACTIONS
.TP
.B \f[B]permit=[true|false]\f[]
permit or disallow the entry, defaults to true
.RS
.RE
.TP
.B \f[B]require_pass=[true|false]\f[]
if entry matches, require a password, defaults to true
.RS
.RE
.TP
.B \f[B]reason=[true|false]\f[]
require a reason for execution/edit, defaults to false
.RS
.RE
.TP
.B \f[B]last=[true|false]\f[]
if true, stop processing when entry is matched, defaults to false
.RS
.RE
.TP
.B \f[B]syslog=[true|false]\f[]
log this activity to syslog, defaults to true
.RS
.RE
.TP
.B \f[B]env_assign.[key]=[value]\f[]
forcefully assign \f[B]value\f[] to environment \f[B]key\f[].
.RS
.RE
.TP
.B \f[B]editmode=[octal mode]\f[]
(\f[B]type=edit\f[]) set the file mode bits on replacement file to octal
mode, defaults to 0600
.RS
.RE
.TP
.B \f[B]exitcmd=[program]\f[]
(\f[B]type=edit\f[]) run program after editor exits as the target user,
if exit is zero, continue with file replacement.
\f[B]%{NEW}\f[] and \f[B]%{OLD}\f[] placeholders expand to new and old
edit files
.RS
.RE
.SH EXAMPLES
.PP
To allow all commands, you can use a greedy match (\f[B]^.*$\f[]).
You should reduce this to the set of acceptable commands though.
.IP
.nf
\f[C]
[user_jim_root]
name=jim
target=root
regex=^.*$
\f[]
.fi
.PP
If you wish to permit a user to view another's command set, then you may
do this using \f[B]type=list\f[] (\f[B]run\f[] by default).
To list another user, they must match the \f[B]target\f[] regex.
.IP
.nf
\f[C]
[user_jim_list_root]
name=jim
type=list
target=root
\f[]
.fi
.PP
\f[B]type\f[] may also be \f[B]edit\f[] if you wish to permit a file
edit with \f[B]pleaseedit\f[].
.IP
.nf
\f[C]
[user_jim_edit_hosts]
name=jim
type=edit
target=root
regex=^/etc/hosts$
\f[]
.fi
.PP
Naming sections should help later when listing permissions.
.PP
Below, user \f[B]mandy\f[] may run \f[B]du\f[] without needing a
password, but must enter her password for a \f[B]bash\f[] running as
root:
.IP
.nf
\f[C]
[mandy_du]
name\ =\ mandy
regex\ =\ ^(/usr)?/bin/du\\s+.*$
require_pass\ =\ false
[mandy_some]
name\ =\ mandy
regex\ =\ ^(/usr)?/bin/bash$
require_pass\ =\ true
\f[]
.fi
.PP
\f[B]regex\f[] can include repetitions.
To permit running \f[B]wc\f[] to count the lines in the log files (we
don't know how many there are) in \f[B]/var/log\f[].
This sort of regex will allow multiple instances of a \f[B]()\f[] group
with \f[B]+\f[], which is used to define the character class
\f[B][a\-zA\-Z0\-9\-]+\f[], the numeric class \f[B]+\f[] and the group
near the end of the line.
In other words, multiple instances of files in \f[B]/var/log\f[] that
may end in common log rotate forms \f[B]\-YYYYMMDD\f[] or \f[B].N\f[].
.PP
This will permit commands such as the following, note how for efficiency
find will combine arguments with \f[B]+\f[] into fewer invocations.
\f[B]xargs\f[] could have been used in place of \f[B]find\f[].
.IP
.nf
\f[C]
$\ find\ /var/log\ \-type\ f\ \-exec\ please\ /usr/bin/wc\ {}\ \\+
\f[]
.fi
.PP
Here is a sample for the above scenario:
.IP
.nf
\f[C]
[user_jim_root_wc]
name=jim
target=root
permit=true
regex=^/usr/bin/wc\ (/var/log/[a\-zA\-Z0\-9\-]+(\\.\\d+)?(\\s)?)+$
\f[]
.fi
.PP
User jim may only start or stop a docker container:
.IP
.nf
\f[C]
[user_jim_root_docker]
name=jim
target=root
permit=true
regex=^/usr/bin/docker\ (start|stop)\ \\S+
\f[]
.fi
.PP
User ben may only edit \f[B]/etc/fstab\f[]:
.IP
.nf
\f[C]
[ben_fstab]
name=ben
target=root
permit=true
type=edit
regex=^/etc/fstab$
\f[]
.fi
.PP
User ben may list only users \f[B]eng\f[], \f[B]net\f[] and
\f[B]dba\f[]:
.IP
.nf
\f[C]
[ben_ops]
name=ben
permit=true
type=list
target=^(eng|net|dba)ops$
\f[]
.fi
.PP
All users may list their own permissions.
You may or may not wish to do this if you consider permitting a view of
the rules to be a security risk.
.IP
.nf
\f[C]
[list_own]
name=^%{USER}$
permit=true
type=list
target=^%{USER}$
\f[]
.fi
.SH EXITCMD
.PP
When the user completes their edit, and the editor exits cleanly, if
\f[B]exitcmd\f[] is included then this program will run as the target
user.
If the program also exits cleanly then the temporary edit will be copied
to the destination.
.PP
\f[B]%{OLD}\f[] and \f[B]%{NEW}\f[] will expand to the old (existing
source) file and edit candidate, respectively.
To verify a file edit, \f[B]ben\f[]'s entry to check \f[B]/etc/hosts\f[]
after clean exit could look like this:
.IP
.nf
\f[C]
[ben_ops]
name=ben
permit=true
type=edit
regex=^/etc/hosts$
exitcmd=/usr/local/bin/check_hosts\ %{OLD}\ %{NEW}
\f[]
.fi
.PP
\f[B]/usr/local/bin/check_hosts\f[] takes two arguments, the original
file as the first argument and the modify candidate as the second
argument.
If \f[B]check_hosts\f[] terminates zero, then the edit is considered
clean and the original file is replaced with the candidate.
Otherwise the edit file is not copied and is left, \f[B]pleaseedit\f[]
will exit with the return value from \f[B]check_hosts\f[].
.PP
A common \f[B]exitcmd\f[] is to check the validity of
\f[B]please.ini\f[], shown below.
This permits members of the \f[B]admin\f[] group to edit
\f[B]/etc/please.ini\f[] if they provide a reason (\f[B]\-r\f[]).
Upon clean exit from the editor the tmp file will be syntax checked.
.IP
.nf
\f[C]
[please_ini]
name\ =\ admins
group\ =\ true
reason\ =\ true
regex\ =\ /etc/please.ini
type\ =\ edit
editmode\ =\ 600
exitcmd\ =\ /usr/bin/please\ \-c\ %{NEW}
\f[]
.fi
.SH DATED RANGES
.PP
For large environments it is not unusual for a third party to require
access during a short time frame for debugging.
To accommodate this there are the \f[B]notbefore\f[] and
\f[B]notafter\f[] time brackets.
These can be either \f[B]YYYYmmdd\f[] or \f[B]YYYYmmddHHMMSS\f[].
.PP
The whole day is considered when using the shorter date form of
\f[B]YYYYmmdd\f[].
.PP
Many enterprises may wish to permit periods of access to a user for a
limited time only, even if that individual is considered to have a
permanent role.
.PP
User joker can do what they want as root on 1st April 2021:
.IP
.nf
\f[C]
[joker_april_first]
name=joker
target=root
permit=true
notbefore=20210401
notafter=20210401
regex=^/bin/bash
\f[]
.fi
.SH DATEMATCHES
.PP
\f[B]datematch\f[] matches against the date string \f[B]Day dd mon
HH:MM:SS UTC Year\f[].
This enables calendar style date matches.
.PP
Note that the day of the month (\f[B]dd\f[]) will be padded with spaces
if less than two characters wide.
.PP
You can permit a group of users to run \f[B]/usr/local/housekeeping/\f[]
scripts every Monday:
.IP
.nf
\f[C]
[l2_housekeeping]
name=l2users
group=true
target=root
permit=true
regex\ =\ /usr/local/housekeeping/.*
datematch\ =\ ^Mon\\s+.*
\f[]
.fi
.SH REASONS
.PP
When \f[B]reason=true\f[], require a reason before permitting edits or
execution with the \f[B]\-r\f[] option to \f[B]please\f[] and
\f[B]pleaseedit\f[].
Some organisations may prefer a reason to be logged when a command is
executed.
This can be helpful for some situations where something such as
\f[B]mkfs\f[] or \f[B]useradd\f[] might be preferable to be logged
against a ticket.
.IP
.nf
\f[C]
[l2_user_admin]
name=l2users
group=true
target=root
permit=true
reason=true
regex\ =\ ^/usr/sbin/useradd\\s+\-m\\s+\\w+$
\f[]
.fi
.SH DIR
.PP
In some situations you may only want a command to run within a set of
directories.
The directory is specified with the \f[B]\-d\f[] argument to
\f[B]please\f[].
For example, a program may output to the current working directory,
which may only be desirable in certain locations.
.IP
.nf
\f[C]
[eng_build_aliases]
name=l2users
group=true
dir=^/etc/mail$
regex\ =\ ^/usr/local/bin/build_aliases$
\f[]
.fi
.SH LAST
.PP
\f[B]last=true\f[] stops processing at a match:
.IP
.nf
\f[C]
[mkfs]
name=l2users
group=true
target=root
permit=true
reason=true
regex\ =\ ^/sbin/mkfs.(ext[234]|xfs)\ /dev/sd[bcdefg]\\d?$
last=true
\f[]
.fi
.PP
For simplicity, there is no need to process other configured rules if
certain that the \f[B]l2users\f[] group are safe to execute this.
\f[B]last\f[] should only be used in situations where there will never
be something that could contradict the match in an undesired way later.
.SH SYSLOG
.PP
By default entries are logged to syslog.
If you do not wish an entry to be logged then specify
\f[B]syslog=false\f[].
In this case \f[B]jim\f[] can run anything in \f[B]/usr/bin/\f[] as root
and it will not be logged.
.IP
.nf
\f[C]
[maverick]
syslog\ =\ false
name\ =\ jim
regex\ =\ /usr/bin/.*
reason\ =\ false
\f[]
.fi
.SH FILES
.PP
/etc/please.ini
.SH NOTES
.PP
At a later date repeated properties within the same section may be
treated as a match list.
.PP
At a later date sections with names containing `default' may behave
differently to normal sections.
.SH CONTRIBUTIONS
.PP
I welcome pull requests with open arms.
New features always considered.
.SH BUGS
.PP
Found a bug?
Please either open a ticket or send a pull request/patch.
.SH SEE ALSO
.PP
\f[B]please\f[](1)
.SH AUTHORS
Ed Neville (ed\-please\@s5h.net).
